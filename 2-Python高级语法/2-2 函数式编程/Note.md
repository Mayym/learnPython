# Python语言的高级特性

# 1、函数式编程(FunctionalProgramming)
- 基于lambda演算的一种编程方式
    - 程序中只有函数
    - 函数可以作为参数，同样可以作为返回值
    - 纯函数式编程语言： LISP，Haskell
- Python函数式编程只是借鉴函数式编程的一些特点，可以理解成一半函数式一半Python
- 函数式编程
    - 高阶函数
    - 返回函数
    - 匿名函数
    - 装饰器
    - 偏函数

## 1.1 lambda表达式
- 函数： 最大程度复用代码
    - 存在问题： 如果函数很小，很短，则会总成啰嗦
        
            # "小"函数举例
            def printA():
                print("AAAAAAA")    
            printA()
        
    - 如果函数被调用次数少，则会造成浪费
    - 对于阅读者来说，造成阅读流程的被迫中断
- lambda表达式（匿名函数）
    - 一个表达式，函数体相对简单
    - 不是一个代码块，仅仅是一个表达式
    - 可以有参数，有多个参数也可以，用逗号隔开
- lambda表达式的用法
    1. 以lambda开头
    2. 紧跟一定的参数（如果有的话）
    3. 参数后用冒号和表达式主体隔开
    4. 只是一个表达式，所以没有return
- 案例 1-1.py

## 1.2 高阶函数
- 把函数作为参数使用的函数，叫高阶函数
   
        # 变量可以赋值
        a = 100
        b = a
    
        # 函数名称就是一个变量
        def funA():
            print("In funA")
        
        funB = funA
        funB()
    - 以上代码得出的结论：
        - 函数名称是变量
        - funB和funA只是名称不一样而已
        - 既然函数名称是变量，则应该可以被当做参数传入另一个参数
- 案例 1-2.py

### 1.2.1 系统高阶函数-map
- 案例 1-2-1.py，1-2-1(1).py
- 原意就是映射，即把集合或者列表的元素，每一个元素都按照一定规则进行操作，生成一个新的列表或者集合
- map函数是系统提供的具有映射功能的函数，返回值是一个迭代对象
- map类型的变量经过一次for循环遍历之后，里面的元素都没有了
    - [原因](https://blog.csdn.net/swety_gxy/article/details/83063499?utm_source=blogxgwz5)
    - 遍历完最后一个元素后，再次访问时会放回空列表
    
### 1.2.2 系统高阶函数-reduce
- 案例 1-2-2.py
- 原意是归并，缩减
- 把一个可迭代对象最后归并成一个结果
- 对于作为参数的函数要求： 必须有两个参数，必须有返回结果

       reduce([1,2,3,4,5]) == f(f(f(f(1,2),3),4),5)
       
- reduce需要导入functools包

### 1.2.3 filter函数
- 案例 1-2-3.py
- 过滤函数： 对一组数据进行过滤，符合条件的数据会生成一个新的列表并返回
- 跟map相比较：
    - 相同：都对列表的每一个元素逐一进行操作
    - 不同：
        - map会生成一个跟原数据相对应的新队列
        - filter不一定，只要符合条件的才会进入新的数据集合
- filter函数怎么写：
    - 利用给定函数进行判断
    - 返回值一定是个布尔值
    - 调用格式： filter(f, data)，f是过滤函数，data是数据

### 1.2.4 高阶函数-排序
- 案例 1-2-4.py
- 把一个序列按照给定算法进行排序
- key： 在排序前对每一个元素进行key函数运算，可以理解成按照key函数定义的逻辑进行排序
- python2 和 python3 相差大

## 1.3 返回函数
- 案例 1-3.py
- 函数可以返回具体的值
- 也可以返回一个函数作为结果

## 1.4 闭包（closure）
- 当一个函数在内部定义函数，并且内部的函数应用外部函数的参数或者局部变量，当内部函数被
    当做返回值的时候，相关参数和变量保存在返回的函数中，这种结果叫闭包
- 案例 1-3.py 中的my_func4是一个标准闭包结构

### 1.4.1 出现的问题
- 案例 1-4.py：闭包常见的坑
- 造成上述状况的原因是，返回函数引用了变量i，i并非立即执行，而是等到三个函数都返回
    的时候才统一使用，此时i已经变成了3，最终调用的时候，都返回的是 3*3
- 此问题描述成：返回闭包时，返回函数不能引用任何循环变量
- 解决方案： 再创建一个函数，用该函数的参数绑定循环变量的当前值，无论该循环变量以后
    如何改变，已经绑定的函数参数值不再改变
    
## 1.5 装饰器（Decorator）
- 案例 1-5.py
- 在不改动函数代码的基础上无限制扩展函数功能的一种机制，本质上讲，装饰器是一个
    返回函数的高阶函数
- 装饰器的使用： 
    - ① 使用@语法，即在每次要扩展到函数定义前使用@+函数名（借用系统定义的语法糖）
    - ② 手动执行装饰器
- 装饰器的好处： 
    - 一旦定义，则可以装饰任意函数
    - 一旦被其装饰，则把装饰器的功能直接添加到定义函数的功能上

## 1.6 偏函数
- 案例 1-6-1.py，1-6-2.py
- 参数固定的函数，相当于一个有特定参数的函数体
- functools.partial的作用是，把一个函数某些参数固定，返回一个新函数

## 1.7 补充几个高级函数
- zip
    - 把两个可迭代内容生成一个可迭代的tuple元素类型组成的内容
    - 案例 1-7-1.py
- enumerate
    - 跟zip功能比较像
    - 对可迭代对象里的每一个元素，配上一个索引，然后索引和内容构成tuple类型
    - 案例 1-7-2.py
- collections模块
    - 案例 1-7-3.py
    - namedtuple
        - tuple类型
        - 是一个可命名的tuple
    - deque
        - 比较方便的解决了频繁删除插入带来的效率问题（如在列表中间删除或插入会导致后面全部元素索引的变化）
- defaultdict
    - 案例 1-7-4.py
    - 当直接读取dict不存在的属性时，直接返回默认值    
- Counter
    - 统计字符串个数
    - 案例 1-7-5.py
    